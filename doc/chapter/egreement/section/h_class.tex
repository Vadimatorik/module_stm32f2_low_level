\section{Объявление классов в .h файлах}\label{class:0}
\begin{enumerate}
	\item Общие сведения об оформлении class-ов в .h файлах (подраздел~\ref{OBK}).
	\item В public области должны располагаться (с соблюдением последовательности сверху вниз):\begin{itemize}
		\item конструктор(-ы) класса (подраздел~\ref{K:0:0});
		\item constexpr конструктор(-ы) класса (подраздел~\ref{K:0:1});
		\item constexpr методы класса (подраздел~\ref{constexpr:0});
		\item доступные пользователю нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип данных (подраздел~\ref{dp:n:s});
		\item доступные пользователю нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип данных (подраздел~\ref{dp:n:n};
		\item доступные пользователю статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип (подраздел~\ref{dp:s:s});
		\item доступные пользователю статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип (подраздел~\ref{dp:s:n});
		\item открытие переменные и константы класса, доступные пользователю напрямую (подраздел~\ref{dp:op}).
	\end{itemize}
	\item В private область должны располагаться (с соблюдением последовательности сверху вниз):\begin{itemize}
		\item внутренние constexpr методы класса, возвращающие значение стандартного типа или указатель на стандартный тип данных (подраздел~\ref{zp:constexpr:s});
		\item внутренние constexpr методы класса, возвращающие значение нестандартного типа или указатель на нестандартный тип данных (подраздел~\ref{zp:constexpr:n});
		\item закрытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип данных (подраздел~\ref{zp:n:s});
		\item закрытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип данных (подраздел~\ref{zp:n:n});
		\item закрытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип (подраздел~\ref{zp:s:s});
		\item закрытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип (подраздел~\ref{zp:s:n});
		\item закрытые константы класса стандартных типов (подраздел~\ref{zp:const:s}).
		\item закрытые константы класса нестандартных типов (подраздел~\ref{zp:const:n}).
		\item закрытые переменные класса стандартных типов (подраздел~\ref{zp:pp:s}).
		\item закрытые переменные класса нестандартных типов (подраздел~\ref{zp:pp:n}).
	\end{itemize}
\end{enumerate}

\subsection{Общие сведения об оформлении class-ов в .h файлах}\label{OBK}
\begin{itemize}
	\item Между зарезервированным словом class и именем класса ставится один (1) пробел.
	\item Между последним символом имени класса и открывающейся фигурной скобкой ставится один (1) пробел.
	\item Сначала идет public, а за ним private область.
	\item <<\}>> (скобка закрывающая тело класса) должна находится на новой строке.
\end{itemize}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
class name_class {
public:
private:
};\end{lstlisting}

\subsection{Конструктор(-ы) класса}\label{K:0:0}
Использование не constexpr конструкторов классов запрещено. Это связано с неочевидной последовательностью вызова конструкторов глобальных объектов, которая может привести к неверной инициализации объекта (если явно не указывать последовательность вызовов с помощью специальных директив компоновщика). Например, сначала будет предпринята попытка инициализировать внешнюю переферию (за пределами микроконтроллера), не инициализировав интерфейс, по которому она подключена.

В случае если пользователь все же создаст объект, конструктор которого будет требовать выполнения кода функции конструктора во время инициализации, вызов его метода инициализации произведен не будет (объект останется не инициализированным).

\subsection{Constexpr конструктор(-ы) класса}\label{K:0:1}
\begin{itemize}
	\item В случае, если конструкторов несколько, они должны быть расположены от большего количества входных параметров к меньшему.
	\item Реализация самого конструктора не должна находится в теле класса. Ее (реализацию конструктора) следует вынести в отдельный файл.
	\item Перед словом constexpr должен быть выполнен отступ в 1 tab.	
	\item Между словом constexpr и именем конструктора(-ов) ставится один (1) пробел.
	\item После имени конструктора должен быть выполнен один (1) пробел. 
	\item Аргументы конструктора(-ов) в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов конструктора должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	constexpr pin ( const pin_config_t *pin_cfg_array, const uint32_t pin_cout );
	constexpr pin ( const pin_config_t *pin_cfg_array );
\end{lstlisting}

\subsection{Constexpr методы класса}\label{constexpr:0}
Размещение constexpr методов в разделе public запрещено и не имеет смысла.

\subsection{Доступные пользователю нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип данных}\label{dp:n:s}
\begin{itemize}
	\item Перед типом возвращаемого значения должен быть выполнен отступ в один (1) tab.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в один (1) пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
	\item В случае, если метод не изменяет данные класса, после параметров в скобках следует поставить один (1) пробел, после чего слово <<const;>>. <<;>> закрывает заголовок функции.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	void	set			( void ) const;
	void	reset		( void ) const;
	void	invert	( void ) const;
	int		read		( void ) const;
\end{lstlisting}

\subsection{Доступные пользователю нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип данных}\label{dp:n:n}
\begin{itemize}
	\item В качестве нестандартного типа может выступать enum class или структура.
	\item В качестве указателя на нестандартный тип может выступать указатель на enum class переменную или структуру.
	\item Перед возвращаемым типом метода должен быть отступ в один (1) tab.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	E_ANSWER_GP	met_g	( void );
\end{lstlisting}

\subsection{Доступные пользователю статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип}\label{dp:s:s}	\begin{itemize}
	\item Перед зарезервированным словом <<static>> должен быть отступ в один (1) tab.
	\item Между <<static>> и типом возвращаемого значения должен быть выполнен отступ в один (1) пробел.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
	\item Так как предполагается, что данный метод будет работать с объектом(-ами) класса, в котором(-ых) описан его заголовок, то первым аргументом метода должен быть указатель на void, который внутри класса будет разыменован в указатель на объект класса, в котором был объявлен.\\Используется указатель на void, а не на объект класса с целью совместимости с FreeRTOS, написанной на C.
	\item Первый аргумент метода следует называть <<void *obj>>.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	static void	task_1	( void *obj );
	static int	m_1			( void *obj );
\end{lstlisting}

\subsection{Доступные пользователю статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип}\label{dp:s:n}
\begin{itemize}
	\item В качестве нестандартного типа может выступать enum class или структура.
	\item В качестве указателя на нестандартный тип может выступать указатель на enum class переменную или структуру.
	\item Перед зарезервированным словом <<static>> должен быть отступ в один (1) tab.
	\item Между <<static>> и типом возвращаемого значения должен быть выполнен отступ в один (1) пробел.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
	\item Так как предполагается, что данный метод будет работать с объектом(-ами) класса, в котором(-ых) описан его заголовок, то первым аргументом метода должен быть указатель на void, который внутри класса будет разыменован в указатель на объект класса, в котором был объявлен.\\Используется указатель на void, а не на объект класса с целью совместимости с FreeRTOS, написанной на C.
	\item Первый аргумент метода следует называть <<void *obj>>.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	static E_ANSWER_GP	met_a	( void *obj );
\end{lstlisting}

\subsection{Открытие переменные и константы класса, доступные пользователю напрямую}\label{dp:op}
Размещение переменных (изменяемых или заданных как const) в public области запрещено. Даже в случае, если требуется просто читать/записывать одну переменную, следует сделать отдельный метод(-ы) для этого. Так как прямое чтение данных из класса является нарушением ООП.

\subsection{Внутренние constexpr методы класса, возвращающие значение стандартного типа или указатель на стандартный тип данных}\label{zp:constexpr:s}
\begin{itemize}
	\item Реализация тела функции не должна находится в теле класса. Она (реализация тела функции) должна быть вынесена в отдельный файл. Допускаются только заголовки функций.
	\item Перед словом constexpr должен быть выполнен отступ в один (1) tab.
	\item Между зарезервированным словом constexpr и типом возвращаемого значения требуется поставить один (1) пробел.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
\end{itemize}
\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	constexpr uint32_t	moder_reg_reset_init_msk_get	( EC_PORT_NAME port_name );
\end{lstlisting}

\subsection{Внутренние constexpr методы класса, возвращающие значение нестандартного типа или указатель на нестандартный тип данных}\label{zp:constexpr:n}
\begin{itemize}
	\item В качестве нестандартного типа может выступать enum class или структура.
	\item В качестве указателя на нестандартный тип может выступать указатель на enum class переменную или структуру.
	\item Реализация тела функции не должна находится в теле класса. Она (реализация тела функции) должна быть вынесена в отдельный файл. Допускаются только заголовки функций.
	\item Перед словом constexpr должен быть выполнен отступ в один (1) tab.
	\item Между зарезервированным словом constexpr и типом возвращаемого значения требуется поставить один (1) пробел.
	\item Имена методов должны быть выравнены с помощью tab с остальными методами этого типа. Выравнивание методов других типов производится по иной сетке.
	\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).
	\item Внутри скобок перечисления аргументов метода должен быть отступ в 1 пробел с каждой стороны.\\\textbf{Пример: } <<( uint32\_t a, uint8\_t b )>>.
\end{itemize}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	constexpr EC_PORT_NAME	port_name_get	( uint32_t value_reg );
\end{lstlisting}

\subsection{Закрытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип данных}\label{zp:n:s}
Оформляются так же, как и открытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип данных (подраздел~\ref{dp:n:s}).

\subsection{Закрытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип данных}\label{zp:n:n}
Оформляются так же, как и открытые нестатические методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип данных (подраздел~\ref{dp:n:n}).

\subsection{Закрытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип}\label{zp:s:s}
Оформляются так же, как и открытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение стандартного типа или указатель на стандартный тип (подраздел~\ref{dp:s:s}).

\subsection{Закрытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип}\label{zp:s:n}
Оформляются так же, как и открытые статические (static) методы класса, выполняющиеся в реальном времени и возвращающие значение нестандартного типа или указатель на нестандартный тип (подраздел~\ref{dp:s:n}).

\subsection{Закрытые константы класса стандартных типов}\label{zp:const:s}
\begin{itemize}
	\item На одной строке допустимо объявлять лишь одну константу.
	\item Перед зарезервированным словом <<const>> должен быть поставлен один (1) tab.
	\item Имена констант должны быть выравнены с помощью tab с остальными константами этого типа. Выравнивание констант других типов производится по иной сетке.
\end{itemize}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	const uint32_t	count;
\end{lstlisting}

\subsection{Закрытые константы класса нестандартных типов}\label{zp:const:n}
Оформляются так же, как и закрытые константы класса стандартных типов (подраздел~\ref{zp:const:s})\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	const global_port_msk_reg_struct	gb_msk_struct;
\end{lstlisting}

\subsection{Закрытые переменные класса стандартных типов}\label{zp:pp:s}
\begin{itemize}
	\item На одной строке допустимо объявлять лишь одну переменную.
	\item Перед типом должен быть поставлен один (1) tab.
	\item Имена переменных должны быть выравнены с помощью tab с остальными переменными этого типа. Выравнивание переменных других типов производится по иной сетке.
\end{itemize}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	uint32_t	flag;
\end{lstlisting}

\subsection{Закрытые переменные класса нестандартных типов}\label{zp:pp:n}
Оформляются так же, как и закрытые переменные класса стандартных типов (подраздел~\ref{zp:pp:s})\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{10}{10}\ttfamily]
	EC_FL	mb_msk_struct;
\end{lstlisting}