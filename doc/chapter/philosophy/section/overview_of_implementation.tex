\section{Краткий обзор реализации библиотеки}
\begin{enumerate}
	\item Библиотека написана на C++14. 
	\item Большую часть библиотеки составляют constexpr функции, которые обрабатывают заполненные пользователем структуры инициализации периферии на этапе компиляции и создают маски регистров для всевозможных, указанных в структуре инициализации, режимов.
	
	В реальном времени созданные из const constexpr структур инициализации глобальные const constexpr объекты в коде пользователя оперируют созданными на этапе компиляции масками регистров для работы с периферийными блоками.
	
	Этим достигается высокая производительность. Поскольку программе не нужно <<собирать>> маски регистров в реальном времени, как это сделано в HAL или SPL. Достаточно только применить маску.
	\item Тот факт, что для инициализации глобальных объектов используются глобальные const constexpr структуры вовсе не означает, что данные структуры войдут в состав прошивки контроллера.
	
	Яркий тому пример, объект класса global\_\-port (который будет рассмотрен в разделе~\ref{gp:0}). Он принимает в себя массив const constexpr pin\_config\_t структур, после чего private constexpr методы объекта класса global\_\-port их (структуры) анализируют и возвращают private global\_\-port\_\-msk\_\-reg\_\-struct структуру, которая будет private структурой глобального объекта класса global\_\-port.
	
	Структуры pin\_\-config\_\-t, использовавшиеся для инициализации private global\_\-port\_\-msk\_\-reg\_\-struct, во flash загружены не будут, потому что в ходе работы программы обращений к ним не будет.
	\label{kor:0}
	\item Для работы с аппаратной частью контроллера используются объявленные в коде пользователя глобальные const constexpr объекты. В качестве параметра(-ов) конструктора передается(-ются) указатель(-и) на const constexpr глобальную(-ые) структуру(-ы). Важно отметить следующее:
	\begin{itemize}
		\item В случае, если после анализа структур(-ы) инициализации они(-на) больше не требуется - компоновщик не включит эти(-у) структуры(-у) в состав выходного файла программы (о чем было сказано в пункте~\ref{kor:0}). Однако в случае, если используемая структура инициализации, возможно, будет использована во время выполнения программы, как, например, в классе pin, описанного в разделе~\ref{pin:0}, то она обязательно пойдет в состав выходной программы.
		\item Так как конструкторы классов используемых в коде пользователя объектов объявлены внутри класса как constexpr, то создание этих объектов, по сути, заключается в простом копировании в оперативную память их изменяемых данных. Никаких действий в реальном времени (за исключением копирования в оперативную память изменяемых в процессе работы данных объекта) не производится.
		
		Объекты, классы которых имеют не constexpr конструктор (требующий вызова функции инициализации  объекта (конструктора) перед вызовом main в реальном времени), \textbf{не поддерживаются намеренно}.
		\item Из того, что все объекты объявлены как const constexpr следует, что у каждого глобального объекта, работающего в реальном времени, имеется метод начальной инициализации (и/или переинициализации), вызов которого необходимо произвести из кода пользователя. 
		
		Это очень оправданно, когда требуется инициализировать объекты в определённом порядке в ходе выполнения программы, чего сложно достигнуть, когда объекты вызываются автоматически перед вызовом функции main. Именно это является причиной отказа от поддержки не constexpr конструкторов классов (вызов функций инициализации (конструкторов) которых, без применения дополнительных директив, производится в случайном порядке (нельзя гарантировать, инициализация какого объекта будет произведена раньше)).
		
		\item В случае, если const constexpr объект был объявлен глобально в коде пользователя, но обращений к нему не было на протяжении всей программы, он не будет добавлен в итоговый файл программы. Ситуация здесь аналогична ситуации с глобальными const constexpr структурами.
	\end{itemize}
\end{enumerate}


\label{gp:0}				% global_port начало раздела.
\label{pin:0}				% pin класс в начале описания.
\label{startup:0}			% Начало раздела, посвященного startup файлу.