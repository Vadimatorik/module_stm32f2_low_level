\chapter{ФИЛОСОФИЯ БИБЛИОТЕКИ}
\subsection{Общие сведения}
В основу библиотеки легли следующие постулаты:
\begin{enumerate}
	\item Все, что можно вычислить на этапе компиляции - не должно вычисляться в реальном времени. 
	\item Между производительностью и расходом памяти выбор должен быть в сторону производительности.
	\item Все, что может быть выполнено с помощью аппаратной периферии - не должно выполняться программно.
	\item Библиотека должна иметь как можно больше средств гибкой настройки на этапе компиляции и по минимуму - в реальном времени (в угоду производительности).
	\item Работа программы должна быть по максимуму предсказуема еще на этапе компиляции. Отсюда следует, что все режимы работы периферии должны быть заданы статически.
\end{enumerate}

\subsection{Краткий обзор реализации}
\begin{enumerate}
	\item Библиотека написана на C++14. 
	\item Большую часть библиотеки составляют constexpr функции, которые обрабатывают заполненные пользователем структуры инициализации периферии на этапе компиляции и создают маски регистров для всевозможных, указанных в структуре инициализации, режимов. В реальном времени созданные из const constexpr структур инициализации глобальные объекты в коде пользователя оперируют созданными на этапе компиляции масками регистров для настройки и работы с периферийными блоками.
	
	Этим достигается высокая производительность. Поскольку программе не нужно <<собирать>> маски регистров в реальном времени, как это сделано в HAL или SPL. Достаточно только применить маску.
	\item Тот факт, что для инициализации глобальных объектов используются глобальные const constexpr структуры вовсе не означает, что данные структуры войдут в состав прошивки контроллера.
	
	Яркий тому пример, объект класса global\_\-port (который будет рассмотрен в разделе~\ref{gp:0}). Он принимает в себя массив const constexpr pin\_config\_t структур, после чего private constexpr методы объекта класса global\_\-port их (структуры) анализируют и возвращают private global\_\-port\_\-msk\_\-reg\_\-struct структуру, которая будет private структурой глобального объекта класса global\_\-port.
	
	Структуры pin\_\-config\_\-t, использовавшиеся для инициализации private global\_\-port\_\-msk\_\-reg\_\-struct, во flash загружены не будут, потому что в ходе работы программы обращений к ним не будет.
	\label{kor:0}
	\item Для работы с аппаратной частью контроллера используются объявленные в коде пользователя глобальные объекты. Все они должны быть объявлены как const constexpr. В качестве параметра(-ов) конструктора передается(-ются) указатель(-и) на const constexpr глобальную(-ые) структуру(-ы). Важно отметить следующее:
	\begin{itemize}
		\item В случае, если после анализа структур(-ы) инициализации они(-на) больше не требуется - линкер не включит эти(-у) структуры(-у) в состав выходного файла программы (о чем было сказано в пункте~\ref{kor:0}). Однако в случае, если используемая структура инициализации, возможно, будет использована во время выполнения программы, как, например, в классе pin, описанного в разделе~\ref{pin:0}, то она обязательно пойдет в состав выходной программы.
		\item Так как конструкторы классов используемых в коде пользователя объектов объявлены внутри класса как constexpr, то создание этих объектов, по сути, заключается в простом копировании в оперативную память их изменяемых данных. Никаких действий в реальном времени (за исключением копирования в оперативную память изменяемых в процессе работы данных объекта) не производится.
		
		Объекты, классы которых имеют не constexpr конструктор (требующий вызова функции инициализации (конструктора) объекта перед вызовом main в реальном времени), \textbf{не поддерживаются намеренно}. Подробнее об этом рассказано в разделе, посвященному описанию логики работы startup файла (раздел~\ref{startup:0}).
		\item Из того, что все объекты объявлены как const constexpr следует, что у каждого глобального объекта, работающего с периферией в реальном времени, имеется метод начальной инициализации (и/или пере инициализации), вызов которого необходимо произвести из кода пользователя. 
		
		Это очень оправданно, когда требуется инициализировать объекты в определенном порядке в ходе выполнения программы, чего сложно достигнуть, когда объекты вызываются автоматически перед вызовом функции main. Именно это является причиной отказа от поддержки не constexpr конструктов классов (вызов функций инициализации (конструкторов) которых, без применения дополнительных директив, производится в случайном порядке (нельзя гарантировать, инициализация какого объекта будет произведена раньше)).
		
		\item В случае, если const constexpr объект был объявлен глобально в коде пользователя, но обращений к нему не было на протяжении всей программы, он не будет добавлен в итоговый файл программы. Ситуация здесь аналогична ситуации с глобальными const constexpr структурами.
	\end{itemize}
\end{enumerate}


\label{gp:0}				% global_port начало раздела.
\label{pin:0}				% pin класс в начале описания.
\label{startup:0}			% Начало раздела, посвященного startup файлу.