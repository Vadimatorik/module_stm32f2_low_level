\chapter{СОГЛАШЕНИЕ О НАПИСАНИИ БИБЛИОТЕКИ}
\subsection{Общие положения}
В данной главе будет изложен некоторого рода стандарт, которого следует придерживаться на протяжении всего времени написания кода библиотеки (в идеале, и пользовательского кода тоже).

Стандарт распространяется на:
\begin{enumerate}
	\item Средства сборки (подраздел~\ref{compgcc:0}).
	\item Дерево проекта и именование файлов (подраздел~\ref{dn:0}).
\end{enumerate}

\subsection{Средства сборки}
\label{compgcc:0}
В основе библиотеки лежат constexpr функции, полноценная поддержка которых появилась в C++14. Отсюда следует вывод, что минимально возможная версия используемого языка - C++14. В случае, если в более поздних версиях будет несовместимость с C++14, следует внести изменения в библиотеку, решающие вопросы несовместимости по средствам проверки версии используемого стандарта языка и выбора совместимого с ним участка кода.

Для компиляции библиотеки следует использовать arm-none-eabi-g++ не старее (GNU Tools for ARM Embedded Processors 6-2017-q1-update) 6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512].

\subsection{Дерево проекта и именование файлов}
\label{dn:0}
Правила, касающиеся оформления библиотеки:
\begin{enumerate}
	\item Для файлов, относящихся к работе с блоками периферии, должна существовать своя папка на каждый модуль.
	
	Пример: rcc, port, pwr и т.д.
	
	Имя папки должно содержать только название аппаратного модуля, написанного с маленькой буквы.
	\item Каждая папка, посвященная определенному блоку аппаратной периферии, должна содержать следующие файлы:
	\begin{itemize}
		\item \textbf{perfix\_moduleName.h}
		
		В данном файле должны находится классы, относящиеся к определенному блоку периферии. Объекты этих классов можно использовать в коде пользователя.
		\item \textbf{perfix\_moduleName.cpp}
		
		Если в perfix\_moduleName.h всего один класс, то в данном файле находятся методы класса из файла perfix\_moduleName.h, вызов которых производится в реальном времени. 
		
		В случае, если классов несколько и у них нет static общих методов (используемые двумя и более классами) - данный файл создавать не следует. Вместо этого для уникальных методов каждого класса должен быть свой файл с соответствующим постфиксом (именем класса). Об этом ниже.
		\item \textbf{perfix\_moduleName\_class\_className.cpp}
		
		В случае, если в файле perfix\_moduleName.h более одного класса и какой-то из этих классов имеет методы, доступные только ему - их следует вынести в отдельный файл с постфиксом, соответствующим имени класса, к которому он (метод) относится. 
		
		В случае, если в файле perfix\_moduleName.h один класс, методы, относящиеся к этому классу, должны быть размещены в файле perfix\_\-moduleName\_\-class\_\-className.cpp.
		
		\item \textbf{perfix\_moduleName\_constexpr\_func.h}
		
		В данном файле содержатся все constexpr методы, которые используются классом(-и) из файла perfix\_moduleName.h. Эти методы, как правило, являются private методами класса(-ов). 
		
		В случае, если в файле perfix\_moduleName.h более одного класса, в данном файле должны находятся лишь те методы, которые используются всеми классами файла perfix\_moduleName.h.
		
		В случае, если каждый класс файла perfix\_moduleName.h использует лишь свой определенный набор методов, никак не пересекающийся с остальными классами, данный файл создавать не следует.
		\item \textbf{perfix\_moduleName\_constexpr\_func\_class\_className.h}
		
		В случае, если в файле perfix\_moduleName.h более одного класса и у какого-то из классов имеются constexpr методы, никак не связанные с остальными (используются только им), их следует вынести в отдельный файл. 
		
		В случае, если таких классов несколько (каждый из которых использует свои определенные constexpr методы), то для каждого такого класса следует создать отдельный файл.
		\item \textbf{perfix\_moduleName\_struct.h}
		
		В данном файле содержатся все структуры и enum-ы, используемые всеми классами файла perfix\_moduleName.h.
		
		В случае, если классы не имеют общих структур или enum-ов, данный файл создавать не следует.
		
		В случае, если в perfix\_moduleName.h всего один класс, его структуры и enum-ы должны располагаться здесь без создания конкретного файла под конкретный класс (из пункта ниже).
		\item \textbf{perfix\_moduleName\_struct\_class\_className.h}
		
		В случае, если классов в файле perfix\_moduleName.h более одного и у какого-то из классов имеются структуры или enum-ы, которые используются только им одним, данные структуры и/или enum-ы требуется вынести в отдельный файл с постфиксом имени класса, к которому они относятся.
	\end{itemize}
	В качестве примера рассмотрим дерево папки port библиотеки stm32\_f20x\_f21x (название библиотеки выступает в качестве префикса).
	
	stm32\_f20x\_f21x\_port.h содержит 2 класса (global\_port и pin). У них есть общие структуры, enum-ы и методы. Однако есть и личные (используемые только ими) структуры, enum-ы и constexpr методы. При этом у них нет общих static методов.
	\begin{itemize}
		\item stm32\_f20x\_f21x\_port\_class\_global\_port.cpp
		\item stm32\_f20x\_f21x\_port\_class\_pin.cpp 
		\item stm32\_f20x\_f21x\_port\_constexpr\_func\_class\_global\_port.h
		\item stm32\_f20x\_f21x\_port\_constexpr\_func\_class\_pin.h
		\item stm32\_f20x\_f21x\_port\_constexpr\_func.h
		\item stm32\_f20x\_f21x\_port\_struct\_class\_global\_port.h
		\item stm32\_f20x\_f21x\_port\_struct\_class\_pin.h
		\item stm32\_f20x\_f21x\_port\_struct.h
		\item stm32\_f20x\_f21x\_port.h
	\end{itemize}
\end{enumerate}