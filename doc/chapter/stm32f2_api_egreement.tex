\chapter{СОГЛАШЕНИЕ О НАПИСАНИИ БИБЛИОТЕКИ}
\subsection{Общие положения}
В данной главе будет изложен некоторого рода стандарт, которого следует придерживаться на протяжении всего времени написания кода библиотеки (в идеале, и пользовательского кода тоже).

Стандарт распространяется на:
\begin{enumerate}
	\item Средства сборки (подраздел~\ref{compgcc:0}).
	\item Дерево проекта и именование файлов (подраздел~\ref{dn:0}).
	\item Принятые сокращения (подраздел~\ref{sk:0}).
	\item Общие правила оформления имен (подраздел~\ref{general:rules:0}).
\end{enumerate}

\subsection{Средства сборки}
\label{compgcc:0}
В основе библиотеки лежат constexpr функции, полноценная поддержка которых появилась в C++14. Отсюда следует вывод, что минимально возможная версия используемого языка - C++14. В случае, если в более поздних версиях будет несовместимость с C++14, следует внести изменения в библиотеку, решающие вопросы несовместимости по средствам проверки версии используемого стандарта языка и выбора совместимого с ним участка кода.

Для компиляции библиотеки следует использовать arm-none-eabi-g++ не старее (GNU Tools for ARM Embedded Processors 6-2017-q1-update) 6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512].

\subsection{Дерево проекта и именование файлов}
\label{dn:0}
Правила, касающиеся оформления библиотеки:
\begin{enumerate}
	\item Для файлов, относящихся к работе с блоками периферии, должна существовать своя папка на каждый модуль.
	
	Пример: rcc, port, pwr и т.д.
	
	Имя папки должно содержать только название аппаратного модуля, написанного с маленькой буквы.
	\item Каждая папка, посвященная определенному блоку аппаратной периферии, должна содержать следующие файлы:
	\begin{itemize}
		\item \textbf{perfix\_moduleName.h}
		
		В данном файле должны находится классы, относящиеся к определенному блоку периферии. Объекты этих классов можно использовать в коде пользователя.
		\item \textbf{perfix\_moduleName.cpp}
		
		Если в perfix\_moduleName.h всего один класс, то в данном файле находятся методы класса из файла perfix\_moduleName.h, вызов которых производится в реальном времени. 
		
		В случае, если классов несколько и у них нет static общих методов (используемые двумя и более классами) - данный файл создавать не следует. Вместо этого для уникальных методов каждого класса должен быть свой файл с соответствующим постфиксом (именем класса). Об этом ниже.
		\item \textbf{perfix\_moduleName\_class\_className.cpp}
		
		В случае, если в файле perfix\_moduleName.h более одного класса и какой-то из этих классов имеет методы, доступные только ему - их следует вынести в отдельный файл с постфиксом, соответствующим имени класса, к которому он (метод) относится. 
		
		В случае, если в файле perfix\_moduleName.h один класс, методы, относящиеся к этому классу, должны быть размещены в файле perfix\_\-moduleName\_\-class\_\-className.cpp.
		
		\item \textbf{perfix\_moduleName\_constexpr\_func.h}
		
		В данном файле содержатся все constexpr методы, которые используются классом(-и) из файла perfix\_moduleName.h. Эти методы, как правило, являются private методами класса(-ов). 
		
		В случае, если в файле perfix\_moduleName.h более одного класса, в данном файле должны находятся лишь те методы, которые используются всеми классами файла perfix\_moduleName.h.
		
		В случае, если каждый класс файла perfix\_moduleName.h использует лишь свой определенный набор методов, никак не пересекающийся с остальными классами, данный файл создавать не следует.
		\item \textbf{perfix\_moduleName\_constexpr\_func\_class\_className.h}
		
		В случае, если в файле perfix\_moduleName.h более одного класса и у какого-то из классов имеются constexpr методы, никак не связанные с остальными (используются только им), их следует вынести в отдельный файл. 
		
		В случае, если таких классов несколько (каждый из которых использует свои определенные constexpr методы), то для каждого такого класса следует создать отдельный файл.
		\item \textbf{perfix\_moduleName\_struct.h}
		
		В данном файле содержатся все структуры и enum-ы, используемые всеми классами файла perfix\_moduleName.h.
		
		В случае, если классы не имеют общих структур или enum-ов, данный файл создавать не следует.
		
		В случае, если в perfix\_moduleName.h всего один класс, его структуры и enum-ы должны располагаться здесь без создания конкретного файла под конкретный класс (из пункта ниже).
		\item \textbf{perfix\_moduleName\_struct\_class\_className.h}
		
		В случае, если классов в файле perfix\_moduleName.h более одного и у какого-то из классов имеются структуры или enum-ы, которые используются только им одним, данные структуры и/или enum-ы требуется вынести в отдельный файл с постфиксом имени класса, к которому они относятся.
	\end{itemize}

	Имена всех файлов должны быть написаны строчными латинскими символами (маленькие английские буквы). В том числе и сокращения по типу <<pwr>>.
	
	Все слова в имени должны разделяться символами нижнего подчеркивания. 
	
	В качестве примера рассмотрим дерево папки port библиотеки stm32\_f20x\_f21x (название библиотеки выступает в качестве префикса).
	
	stm32\_f20x\_f21x\_port.h содержит 2 класса (global\_port и pin). У них есть общие структуры, enum-ы и методы. Однако есть и личные (используемые только ими) структуры, enum-ы и constexpr методы. При этом у них нет общих static методов.
	\begin{itemize}
		\item stm32\_f20x\_f21x\_port\_class\_global\_port.cpp
		\item stm32\_f20x\_f21x\_port\_class\_pin.cpp 
		\item stm32\_f20x\_f21x\_port\_constexpr\_func\_class\_global\_port.h
		\item stm32\_f20x\_f21x\_port\_constexpr\_func\_class\_pin.h
		\item stm32\_f20x\_f21x\_port\_constexpr\_func.h
		\item stm32\_f20x\_f21x\_port\_struct\_class\_global\_port.h
		\item stm32\_f20x\_f21x\_port\_struct\_class\_pin.h
		\item stm32\_f20x\_f21x\_port\_struct.h
		\item stm32\_f20x\_f21x\_port.h
	\end{itemize}
\end{enumerate}

\subsection{Принятые сокращения}
\label{sk:0}
\begin{enumerate}
	\item Если uint32\_t переменная содержит внутри себя адрес в памяти (является указателем), то перед ее именем должен быть префикс <<p\_>>.
	
	\textbf{Пример:} <<p\_target\_port>>.
	\item <<bit\_banding\_>> == <<bb\_>>
	
	Только в тексте (не применимо к коду).
	\item <<point\_bit\_banding\_bit\_address>> == <<bb\_p\_>>
	
	Когда uint32\_t переменная содержит адрес бита в bit banding области (является указателем).
	
\end{enumerate}

\subsection{Общие правила оформления имен}
\label{general:rules:0}
\begin{enumerate}
	\item Все имена переменных, структур, объектов, функций должны быть написаны строчными латинскими символами (маленькие английские буквы).
	
	\textbf{Пример: }<<pwr>>, <<port>>, <<value>>.
	\item Директивы препроцессора (define, макросы, ifndef и т.д.) должны писаться заглавными латинскими символами (большие английские буквы). 
	
	\textbf{Пример: }<<ADD(A,B)>>
	\item Слова в именах должны быть разделены нижним подчеркиванием.
	
	\textbf{Пример: }<<buf\_speed>>, <<STM32F2\_\-API\_\-PORT\_\-STM32\_\-F20X\_\-F21X\_\-PORT\_\-STRUCT\_\-CLASS\_\-PIN\_\-H\_>>, <<PORT\_PIN\_0>>
	\item Макросы должны начинаться с префикса <<M\_>>, после чего идет действие, которое он совершает (<<GET>>/<<SET>>).
	
	В именах так же следует использовать принятые сокращения.
	
	\textbf{Пример: }<<M\_GET\_BB\_P\_PER(ADDRESS,BIT)>>
	\item Имя прототипа enum-а должно начинаться с префикса <<E\_>>.
	
	\textbf{Пример: }<<ENUM\_PIN\_MODE>>.
	\item Элементы enum-ов должны быть написаны заглавными буквами.
	
	\textbf{Пример: }<<PORT\_PIN\_0>>
	\item Рекомендуется воздержаться от использования enum-ов.
	
	Заместо них следует использовать enum class.
	\item Имя прототипа enum class должно начинаться с префикса <<EC\_>>. К нему можно обращаться только через <<::>>.
	
	Прямое обращение к значению enum class-а без указания пространства имен - запрещено.
	
	\textbf{Пример: }<<EC\_PORT\_NAME::A>>
\end{enumerate}
