\chapter{СОГЛАШЕНИЕ О НАПИСАНИИ БИБЛИОТЕКИ}
\section{Общие положения}
В данной главе будет изложен стандарт, которого следует придерживаться на протяжении всего времени написания кода библиотеки, а так же рекомендации по ее (библиотеки) использованию в коде пользователя.

Стандарт распространяется на:
\begin{enumerate}
	\item Средства сборки (раздел~\ref{compgcc:0}).
	\item Дерево проекта и именование файлов (раздел~\ref{dn:0}).
	\item Принятые сокращения (подраздел~\ref{sk:0}).
	\item Общие правила оформления имен (раздел~\ref{general:rules:0}).
	\item Оформление .h файлов библиотеки (раздел~\ref{file:h}).
\end{enumerate}

\section{Средства сборки}
\label{compgcc:0}
В основе библиотеки лежат constexpr функции, полноценная поддержка которых появилась в C++14. Отсюда следует вывод, что минимально возможная версия используемого языка - C++14. В случае, если в более поздних версиях будет несовместимость с C++14, следует внести изменения в библиотеку, решающие вопросы несовместимости по средствам проверки версии используемого стандарта языка и выбора совместимого с ним участка кода.

Для компиляции библиотеки следует использовать arm-none-eabi-g++ не старее (GNU Tools for ARM Embedded Processors 6-2017-q1-update) 6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512].

\section{Дерево проекта и именование файлов}
\label{dn:0}
Правила, касающиеся оформления библиотеки:
\begin{enumerate}
	\item Для файлов, относящихся к работе с блоками периферии, должна существовать своя папка на каждый модуль.\\
	Пример: rcc, port, pwr и т.д.\\
	Имя папки должно содержать только название аппаратного модуля, написанного с маленькой буквы.\\
	\item Каждая папка, посвященная определенному блоку аппаратной периферии, должна содержать следующие файлы:
	\begin{itemize}
		\item \textbf{perfix\_moduleName.h}\\
		В данном файле должны находится классы, относящиеся к определенному блоку периферии. Объекты этих классов можно использовать в коде пользователя.
		\item \textbf{perfix\_moduleName.cpp}\\
		Если в perfix\_moduleName.h всего один класс, то в данном файле находятся методы класса из файла perfix\_moduleName.h, вызов которых производится в реальном времени.\\
		В случае, если классов несколько и у них нет static общих методов (используемые двумя и более классами) - данный файл создавать не следует. Вместо этого для уникальных методов каждого класса должен быть свой файл с соответствующим постфиксом (именем класса). Об этом ниже.
		\item \textbf{perfix\_moduleName\_class\_className.cpp}\\
		В случае, если в файле perfix\_moduleName.h более одного класса и какой-то из этих классов имеет методы, доступные только ему - их следует вынести в отдельный файл с постфиксом, соответствующим имени класса, к которому он (метод) относится.\\
		В случае, если в файле perfix\_moduleName.h один класс, методы, относящиеся к этому классу, должны быть размещены в файле perfix\_\-moduleName.cpp.
		\item \textbf{perfix\_moduleName\_constexpr\_func.h}\\
		В данном файле содержатся все constexpr методы, которые используются классом(-и) из файла perfix\_moduleName.h. Эти методы, как правило, являются private методами класса(-ов).\\
		В случае, если в файле perfix\_moduleName.h более одного класса, в данном файле должны находятся лишь те методы, которые используются всеми классами файла perfix\_moduleName.h.\\
		В случае, если каждый класс файла perfix\_moduleName.h использует лишь свой определенный набор методов, никак не пересекающийся с остальными классами, данный файл создавать не следует.
		\item \textbf{perfix\_moduleName\_constexpr\_func\_class\_className.h}\\
		В случае, если в файле perfix\_moduleName.h более одного класса и у какого-то из классов имеются constexpr методы, никак не связанные с остальными (используются только им), их следует вынести в отдельный файл.\\
		В случае, если таких классов несколько (каждый из которых использует свои определенные constexpr методы), то для каждого такого класса следует создать отдельный файл.
		\item \textbf{perfix\_moduleName\_struct.h}\\		
		В данном файле содержатся все структуры и enum class-ы, используемые всеми классами файла perfix\_moduleName.h.\\		
		В случае, если классы не имеют общих структур или enum class-ов, данный файл создавать не следует.\\		
		В случае, если в perfix\_moduleName.h всего один класс, его структуры и enum class-ы должны располагаться здесь без создания конкретного файла под конкретный класс (из пункта ниже).
		\item \textbf{perfix\_moduleName\_struct\_class\_className.h}\\		
		В случае, если классов в файле perfix\_moduleName.h более одного и у какого-то из классов имеются структуры или enum class-ы, которые используются только им одним, данные структуры и/или enum class-ы требуется вынести в отдельный файл с постфиксом имени класса, к которому они относятся.
	\end{itemize}

	Имена всех файлов должны быть написаны строчными латинскими символами (маленькие английские буквы). В том числе и сокращения по типу <<pwr>>.
	
	Все слова в имени должны разделяться символами нижнего подчеркивания. 
	
	В качестве примера рассмотрим дерево папки port библиотеки stm32\_f20x\_f21x (название библиотеки выступает в качестве префикса).
	
	stm32\_f20x\_f21x\_port.h содержит 2 класса (global\_port и pin). У них есть общие структуры, enum class-ы и методы. Однако есть и личные (используемые только ими) структуры, enum class-ы и constexpr методы. При этом у них нет общих static методов.
	\begin{lstlisting}[language=C++,
	frame=tlBR]
stm32_f20x_f21x_port_class_global_port.cpp
stm32_f20x_f21x_port_class_pin.cpp 
stm32_f20x_f21x_port_constexpr_func_class_global_port.h
stm32_f20x_f21x_port_constexpr_func_class_pin.h
stm32_f20x_f21x_port_constexpr_func.h
stm32_f20x_f21x_port_struct_class_global_port.h
stm32_f20x_f21x_port_struct_class_pin.h
stm32_f20x_f21x_port_struct.h
stm32_f20x_f21x_port.h
	\end{lstlisting}
\end{enumerate}

\section{Принятые сокращения}
\label{sk:0}
\begin{enumerate}
	\item Если uint32\_t переменная содержит внутри себя адрес в памяти (является указателем), то перед ее именем должен быть префикс <<p\_>>.
	
	\textbf{Пример:} <<p\_target\_port>>.
	\item <<bit\_banding\_>> == <<bb\_>>
	
	Только в тексте (не применимо к коду).
	\item <<point\_bit\_banding\_bit\_address>> == <<bb\_p\_>>
	
	Когда uint32\_t переменная содержит адрес бита в bit banding области (является указателем).
	
\end{enumerate}

\section{Общие правила оформления имен}
\label{general:rules:0}
\begin{enumerate}
	\item Все имена переменных, структур, объектов, функций должны быть написаны строчными латинскими символами (маленькие английские буквы).
	
	\textbf{Пример: }<<pwr>>, <<port>>, <<value>>.
	\item Директивы препроцессора (define, макросы, ifndef и т.д.) должны писаться заглавными латинскими символами (большие английские буквы). 
	
	\textbf{Пример: }<<ADD(A,B)>>
	\item Слова в именах должны быть разделены нижним подчеркиванием.
	
	\textbf{Пример: }<<buf\_speed>>, <<STM32F2\_\-API\_\-PORT\_\-STM32\_\-F20X\_\-F21X\_\-PORT\_\-STRUCT\_\-CLASS\_\-PIN\_\-H\_>>, <<PORT\_PIN\_0>>
	\item Макросы должны начинаться с префикса <<M\_>>, после чего идет действие, которое он совершает (<<GET>>/<<SET>>).
	
	В именах так же следует использовать принятые сокращения.
	
	\textbf{Пример: }<<M\_GET\_BB\_P\_PER(ADDRESS,BIT)>>
	\item \textbf{Рекомендуется воздержаться от использования enum-ов}.
	
	Заместо них следует использовать \textbf{enum class}.
	\item Имя прототипа enum class должно начинаться с префикса <<EC\_>>. К нему можно обращаться только через <<::>>.
	
	Прямое обращение к значению enum class-а без указания пространства имен - запрещено.
	
	\textbf{Пример: }<<EC\_PORT\_NAME::A>>
\end{enumerate}

\section{Оформление .h файлов библиотеки}
\label{file:h}
\subsection{Общее оформление}
\begin{enumerate}
	\item <<.h>> файл должен включать в себя защиту от повторного включения файла в процесс компиляции. 
	\begin{lstlisting}[language=C++, frame=tlBR]
#ifndef STM32F2_API_STM32_F20X_F21X_PORT_H_
#define STM32F2_API_STM32_F20X_F21X_PORT_H_

#endif
	\end{lstlisting}
\end{enumerate}

\subsection{Классы}
\begin{enumerate}
	\item Типичный образец класса выглядит следующим образом:
	\begin{lstlisting}[language=C++,frame=tlBR]
class name_class {
public:
private:
};
	\end{lstlisting}
	Из данного примера следует:
	\begin{itemize}
		\item Между зарезервированным словом class и именем класса один (1) пробел.
		\item Между последним символом имени класса и открывающейся фигурной скобкой один (1) пробел.
		\item Сначала идет public область, а затем private.
		\item <<\}>> (скобка закрывающая тело класса) должна находится на новой строке.
	\end{itemize}

	\item В public области должны располагаться (с соблюдением последовательности сверху вниз):
	\begin{itemize}
		\item Constexpr конструктор класса.
		\begin{itemize}
			\item Перед словом constexpr должен быть выполнен отступ в 1 tab.
			\item В случае, если конструкторов несколько, они должны быть расположены от большего количества входных параметров к меньшему.
			\item Реализация самого конструктора не должна находится в теле класса. Ее (реализацию конструктора) следует вынести в отдельный файл.
			\item После слова constexpr и до первого символа имени конструктора, ставится один (1) пробел.
			\item После имени конструктора (класса) должен быть выполнен один (1) пробел. 
			\item Аргументы конструктора в скобках должны быть разделены <<, >> (запятая + пробел).\\По бокам (от каждой скобки) должен быть отступ в 1 пробел.\\Пример: <<( uint32\_t a, uint8\_t b )>>.
		\end{itemize}
		\item В данной области запрещено размещать constexpr методы (за исключением кон\-струк\-то\-ра\-(-ов)).
		\item Доступные пользователю методы, выполняющиеся в реальном времени.
		\begin{itemize}
			\item Перед типом возвращаемого значения должен быть выполнен отступ в 1 tab.
			\item Имена методов должны быть выравнены с помощью tab с остальными методами public области (кроме конструкторов).\\Следует отметить, что речь идет лишь об одинаковых по структуре методах. В случае, если имеются и static методы, они должны будут выравнены между собой по другой сетке (об этом далее).
			\item В случае, если имеется(-ются) static метод(-ы) - он(они) должен(-ы) быть расположен(-ы) самым(ыми) последним(-и) со смещением в выравнивании в одно поле (вместо типа возвращаемого значения - static, вместо имени тип - возвращаемого значения).\\После чего выравнивание идет уже по другой сетки (уникальной для static методов).
			\item В случае, если часть (не все) функций возвращают enum class, то такие функции следует так же разместить после остальных (но до static методов) и создать им отдельную сетку с учетом ширины имени enum class-а.
			\item Аргументы методов в скобках должны быть разделены <<, >> (запятая + пробел).\\По бокам (от каждой скобки) должен быть отступ в 1 пробел.\\Пример: <<( uint32\_t a, uint8\_t b )>>
			\item В случае, если метод не изменяет данные класса, после параметров в скобках следует поставить один (1) пробел, после чего слово <<const;>>. <<;>> закрывает заголовок функции.
		\end{itemize}
		После конструктора(-ов) и методов разных типов (обычные и с префиксом static) следует оставлять пустую строку. 
	\end{itemize}
	\item В private области должны располагаться (с соблюдением последовательности сверху вниз):
	\begin{itemize}
	\item Скрытые constexpr методы класса.
	\begin{itemize}
		\item Перед словом constexpr должен быть выполнен отступ в 1 tab.
		\item Реализация тела функции не должно находится в теле класса (должна быть вынесена в отдельный файл).
		\item Имя функции должно быть выравнено с помощью tab с остальными методами private области.
		\item После имени конструктора (класса) должен быть выполнен один (1) пробел. 
		\item Аргументы в скобках должны быть разделены <<, >> (запятая + пробел).\\По бокам (от каждой скобки) должен быть отступ в 1 пробел.\\Пример: <<( uint32\_t a, uint8\_t b )>>.
		\item Параметры методов должны быть выровнены с помощью tab.
	\end{itemize}
	\item Внутренние методы класса, выполняющиеся в реальном времени.
	\begin{itemize}
		\item Перед типом возвращаемого значения должен быть выполнен отступ в 1 tab.
		\item Имена методов должны быть выравнены с помощью tab с остальными методами private области (только своего типа).
		\item В случае, если имеется(-ются) static метод(-ы) - он(они) должен(-ы) быть расположен(-ы) самым(ыми) последним(-и) со смещением в выравнивании в одно поле (вместо типа возвращаемого значения - static, вместо имени тип - возвращаемого значения).\\После чего выравнивание идет уже по другой сетки (уникальной для static методов).
		\item В случае, если часть (не все) функций возвращают enum class, то такие функции следует так же разместить после остальных (но до static методов) и создать им отдельную сетку с учетом ширины имени enum class-а.
		\item Параметры в скобках должны быть разделены <<, >> (запятая + пробел), в по бокам (от каждой скобки) должен быть отступ в 1 пробел. Пример: <<( uint32\_t a, uint8\_t b )>>
		\item В случае, если метод не изменяет данные класса, после параметров в скобках следует поставить один (1) пробел, после чего слово <<const;>>. <<;>> закрывает заголовок функции. Реализации самих функций должны быть в <<.cpp>> файлах.
	\end{itemize}
	После constexpr методов, обычных методов, методов с префиксом static, следует оставлять пустую строку. 
	\item Данные класса (изменяемые и не изменяемые).
	\begin{itemize}
		\item Переменные должны быть сгруппированы на const (идут первыми) и изменяемые.
		\item В случае, если переменная const, то перед ключевым словом <<const>> требуется поставить один (1) tab. После чего один (1) пробел. Далее идет тип переменной. После типа переменной с помощью tab выравниваются все имена между собой (только между const переменными). В случае. ели переменная является указателем, символ указателя (<<*>>) воспринимается 1-м символом переменной и выравнивается как часть имени.
		\item В случае, если имеются изменяемые данные. Перед типом переменной следует выполнить один tab. После типа переменной с помощью tab выравниваются все имена между собой (только между const переменными). В случае. если переменная является указателем, символ указателя (<<*>>) воспринимается 1-м символом переменной и выравнивается как часть имени.
	\end{itemize}
\end{itemize}
\end{enumerate}

\subsection{Enum class-ы}
\subsection{Комментарии/разделения}
