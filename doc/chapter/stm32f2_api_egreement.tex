\chapter{СОГЛАШЕНИЕ О НАПИСАНИИ БИБЛИОТЕКИ}
\section{Общие положения}
В данной главе будет изложен стандарт, которого следует придерживаться на протяжении всего времени написания кода библиотеки, а так же рекомендации по ее (библиотеки) использованию в коде пользователя.

Стандарт распространяется на:
\begin{enumerate}
	\item средства сборки (раздел~\ref{compgcc:0});
	\item дерево проекта и именование файлов (раздел~\ref{dn:0});
	\item принятые сокращения (подраздел~\ref{sk:0});
	\item общие правила оформления имен (раздел~\ref{general:rules:0});
	\item оформление .h файлов библиотеки (раздел~\ref{file:h});
	\item объявление классов в .h файлах (раздел~\ref{class:0}).
\end{enumerate}

\section{Средства сборки}
\label{compgcc:0}
В основе библиотеки лежат constexpr функции, полноценная поддержка которых появилась в C++14. Отсюда следует вывод, что минимально возможная версия используемого языка - C++14. В случае, если в более поздних версиях будет несовместимость с C++14, следует внести изменения в библиотеку, решающие вопросы несовместимости по средствам проверки версии используемого стандарта языка и выбора совместимого с ним участка кода.

Для компиляции библиотеки следует использовать arm-none-eabi-g++ не старее (GNU Tools for ARM Embedded Processors 6-2017-q1-update) 6.3.1 20170215 (release) [ARM/embedded-6-branch revision 245512].

\section{Дерево проекта и именование файлов}\label{dn:0}
Правила, касающиеся оформления библиотеки:
\begin{enumerate}
	\item Для файлов, относящихся к работе с блоками периферии, должна существовать своя папка на каждый модуль.\\
	Пример: rcc, port, pwr и т.д.\\
	Имя папки должно содержать только название аппаратного модуля, написанного с маленькой буквы.\\
	\item Каждая папка, посвященная определенному блоку аппаратной периферии, должна содержать следующие файлы:
	\begin{itemize}
		\item \textbf{perfix\_moduleName.h}\\
		В данном файле должны находится классы, относящиеся к определенному блоку периферии. Объекты этих классов можно использовать в коде пользователя.
		\item \textbf{perfix\_moduleName.cpp}\\
		Если в perfix\_moduleName.h всего один класс, то в данном файле находятся методы класса из файла perfix\_moduleName.h, вызов которых производится в реальном времени.\\
		В случае, если классов несколько и у них нет static общих методов (используемые двумя и более классами) - данный файл создавать не следует. Вместо этого для уникальных методов каждого класса должен быть свой файл с соответствующим постфиксом (именем класса). Об этом ниже.
		\item \textbf{perfix\_moduleName\_class\_className.cpp}\\
		В случае, если в файле perfix\_moduleName.h более одного класса и какой-то из этих классов имеет методы, доступные только ему - их следует вынести в отдельный файл с постфиксом, соответствующим имени класса, к которому он (метод) относится.\\
		В случае, если в файле perfix\_moduleName.h один класс, методы, относящиеся к этому классу, должны быть размещены в файле perfix\_\-moduleName.cpp.
		\item \textbf{perfix\_moduleName\_constexpr\_func.h}\\
		В данном файле содержатся все constexpr методы, которые используются классом(-и) из файла perfix\_moduleName.h. Эти методы, как правило, являются private методами класса(-ов).\\
		В случае, если в файле perfix\_moduleName.h более одного класса, в данном файле должны находятся лишь те методы, которые используются всеми классами файла perfix\_moduleName.h.\\
		В случае, если каждый класс файла perfix\_moduleName.h использует лишь свой определенный набор методов, никак не пересекающийся с остальными классами, данный файл создавать не следует.
		\item \textbf{perfix\_moduleName\_constexpr\_func\_class\_className.h}\\
		В случае, если в файле perfix\_moduleName.h более одного класса и у какого-то из классов имеются constexpr методы, никак не связанные с остальными (используются только им), их следует вынести в отдельный файл.\\
		В случае, если таких классов несколько (каждый из которых использует свои определенные constexpr методы), то для каждого такого класса следует создать отдельный файл.
		\item \textbf{perfix\_moduleName\_struct.h}\\		
		В данном файле содержатся все структуры и enum class-ы, используемые всеми классами файла perfix\_moduleName.h.\\		
		В случае, если классы не имеют общих структур или enum class-ов, данный файл создавать не следует.\\		
		В случае, если в perfix\_moduleName.h всего один класс, его структуры и enum class-ы должны располагаться здесь без создания конкретного файла под конкретный класс (из пункта ниже).
		\item \textbf{perfix\_moduleName\_struct\_class\_className.h}\\		
		В случае, если классов в файле perfix\_moduleName.h более одного и у какого-то из классов имеются структуры или enum class-ы, которые используются только им одним, данные структуры и/или enum class-ы требуется вынести в отдельный файл с постфиксом имени класса, к которому они относятся.
	\end{itemize}

	Имена всех файлов должны быть написаны строчными латинскими символами (маленькие английские буквы). В том числе и сокращения по типу <<pwr>>.
	
	Все слова в имени должны разделяться символами нижнего подчеркивания. 
	
	В качестве примера рассмотрим дерево папки port библиотеки stm32\_f20x\_f21x (название библиотеки выступает в качестве префикса).
	
	stm32\_f20x\_f21x\_port.h содержит 2 класса (global\_port и pin). У них есть общие структуры, enum class-ы и методы. Однако есть и личные (используемые только ими) структуры, enum class-ы и constexpr методы. При этом у них нет общих static методов.
	\begin{lstlisting}[language=C++,
	frame=tlBR]
stm32_f20x_f21x_port_class_global_port.cpp
stm32_f20x_f21x_port_class_pin.cpp 
stm32_f20x_f21x_port_constexpr_func_class_global_port.h
stm32_f20x_f21x_port_constexpr_func_class_pin.h
stm32_f20x_f21x_port_constexpr_func.h
stm32_f20x_f21x_port_struct_class_global_port.h
stm32_f20x_f21x_port_struct_class_pin.h
stm32_f20x_f21x_port_struct.h
stm32_f20x_f21x_port.h
	\end{lstlisting}
\end{enumerate}

\section{Принятые сокращения}\label{sk:0}
\begin{enumerate}
	\item Если uint32\_t переменная содержит внутри себя адрес в памяти (является указателем), то перед ее именем должен быть префикс <<p\_>>.
	
	\textbf{Пример:} <<p\_target\_port>>.
	\item <<bit\_banding\_>> == <<bb\_>>
	
	Только в тексте (не применимо к коду).
	\item <<point\_bit\_banding\_bit\_address>> == <<bb\_p\_>>
	
	Когда uint32\_t переменная содержит адрес бита в bit banding области (является указателем).
	
\end{enumerate}

\section{Общие правила оформления имен}\label{general:rules:0}
\begin{enumerate}
	\item Все имена переменных, структур, объектов, функций должны быть написаны строчными латинскими символами (маленькие английские буквы).
	
	\textbf{Пример: }<<pwr>>, <<port>>, <<value>>.
	\item Директивы препроцессора (define, макросы, ifndef и т.д.) должны писаться заглавными латинскими символами (большие английские буквы). 
	
	\textbf{Пример: }<<ADD(A,B)>>
	\item Слова в именах должны быть разделены нижним подчеркиванием.
	
	\textbf{Пример: }<<buf\_speed>>, <<STM32F2\_\-API\_\-PORT\_\-STM32\_\-F20X\_\-F21X\_\-PORT\_\-STRUCT\_\-CLASS\_\-PIN\_\-H\_>>, <<PORT\_PIN\_0>>
	\item Макросы должны начинаться с префикса <<M\_>>, после чего идет действие, которое он совершает (<<GET>>/<<SET>>).
	
	В именах так же следует использовать принятые сокращения.
	
	\textbf{Пример: }<<M\_GET\_BB\_P\_PER(ADDRESS,BIT)>>
	\item \textbf{Рекомендуется воздержаться от использования enum-ов}.
	
	Заместо них следует использовать \textbf{enum class}.
	\item Имя прототипа enum class должно начинаться с префикса <<EC\_>>. К нему можно обращаться только через <<::>>.
	
	Прямое обращение к значению enum class-а без указания пространства имен - запрещено.
	
	\textbf{Пример: }<<EC\_PORT\_NAME::A>>
\end{enumerate}

\section{Оформление .h файлов библиотеки}\label{file:h}
\subsection{Общее оформление}
\begin{enumerate}
	\item Файл должен включать в себя защиту от повторного включения в процесс компиляции по типу \textit{ifndef-define-endif}, оканчивающуюся пустой строкой.\\\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{8}{8}\ttfamily]
#ifndef STM32F2_API_STM32_F20X_F21X_PORT_H_
#define STM32F2_API_STM32_F20X_F21X_PORT_H_

#endif\end{lstlisting}

	\item После \textit{define} строки защиты следует пустая строка, за которой располагается \textit{include} на файл конфигурации библиотеки, имеющий имя \textbf{perfix\_conf.h} (название библиотеки выступает в качестве префикса).\\\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{8}{8}\ttfamily]
#define STM32F2_API_STM32_F20X_F21X_PORT_H_

#include "stm32_f20x_f21x_conf.h"\end{lstlisting}
	
	\item В случае, если файл стоит включать в процесс компиляции только при каком-то условии, это условие (обернутое в \textit{ifdef}) необходимо указать через одну пустую строку после \textit{include} файла конфигурации библиотеки. Блок \textit{endif}, закрывающий тело блока условной компиляции должен быть написан без пустой строки перед \textit{endif}, закрывающим блок защиты повторной компиляции.\\\textbf{Пример:}\begin{lstlisting}[language=C++, frame=tlBR, basicstyle=\fontsize{8}{8}\ttfamily]
#ifndef STM32F2_API_STM32_F20X_F21X_PORT_H_
#define STM32F2_API_STM32_F20X_F21X_PORT_H_

#include "stm32_f20x_f21x_conf.h"

#ifdef MODULE_PORT

CODE

#endif
#endif\end{lstlisting}
\end{enumerate}

\input{chapter/class_h.tex}
	
\section{Оформление enum class-ов}

\if 0
\subsection{Комментарии/разделения}
\fi